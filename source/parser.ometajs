//----------------------------------------------------------------------
//
// This source file is part of the furipota project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

const ast = require('./ast');

var reserved = [
  'define',
  'import',
  'true',
  'false'
];

function isValid(id) {
  return reserved.indexOf(id) === -1;
}


ometa FuripotaParser {
  // --[ Lexical structure ]
  space   = /\s/,
  ignored = space | comment,
  comment = fromTo('#', '\n'):a -> a.slice(1),
  ws      = ignored*,
  sws     = ignored+,
  kw :xs  = seq(xs) ~(letter | digit | '-' | '_' | ':'),
  idStart = letter,
  idRest  = (letter | digit | '-' | '_'),
  eof     = ~char,

  octDigits = /[0-7][0-7_]*/:a             -> a.replace(/_/g, ''),
  hexDigits = /[0-9a-fA-F][0-9a-fA-F_]*/:a -> a.replace(/_/g, ''),
  binDigits = /[01][01_]*/:a               -> a.replace(/_/g, ''),
  digits = /[0-9][0-9_]*/:a                -> a.replace(/_/g, ''),

  exponent = ('e' | 'E') sign?:s digits:d -> s + d,
  sign = '+' | '-',

  stringEscape = '\\' ( 'b' -> '\b'
                      | 'f' -> '\f'
                      | 'n' -> '\n'
                      | 'r' -> '\r'
                      | 't' -> '\t'
                      | char),

  stringChar = stringEscape
             | (~seq('"') char):a -> a,
  unescapableChars = ~seq('"""') char,


  Identifier = <idStart idRest*>:a ?isValid(a)
               -> ast.Identifier(a),

  Keyword = <idStart idRest*>:a ':'
            -> ast.Keyword(a),


  // --[ Values ]
  value = Boolean | Number | Text | Vector | Record,

  Boolean = kw('true') -> ast.Boolean(true)
          | kw('false') -> ast.Boolean(false),

  Number = sign?:s ( '0' 'b' binDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 2).toString())
                   | '0' 'o' octDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 8).toString())
                   | '0' 'x' hexDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 16).toString())
                   | digits:a '.' digits:b exponent?:c
                     -> ast.Decimal(s || '+', a, b, c || '')
                   | digits:a
                     -> ast.Integer(s || '+', a)
                   ),


  Text = seq('"""') <unescapableChars*>:as seq('"""')
         -> ast.Text(as)
       | '"' stringChar*:as '"'
         -> ast.Text(as.join('')),

  Vector = '[' ws ']'
           -> ast.Vector([]),
         | '[' ws expression:a (ws ',' expression)*:as ']'
           -> ast.Vector([a].concat(as)),

  Record = '{' ws '}'
           -> ast.Record([])
         | Keyword:k ws expression:v (sws Keyword:k1 ws expression:v1 -> [k1, v1])*:xs
           -> ast.Record([[k, v]].concat(xs)),


  // --[ Declarations ]
  declaration = Define | Import,

  Define = kw('define') ws Identifier:i ws '=' ws expression:e
           -> ast.Define(i, e),

  Import = kw('import') ws Text:p
           -> ast.Import(p),


  // --[ Expressions ]
  expression = Pipe,

  Pipe = Pipe:a ws '>' ws expression:t
         -> ast.Pipe(a, t)
       | Invoke,

  Invoke = primaryExpression:i ws primaryExpression:v ws Record?:r
           -> ast.Invoke(i, v, r || ast.Record([]))
         | primaryExpression:i ws '_' ws Record?:r
           -> ast.Partial(i, r || ast.Record([]))
         | primaryExpression,

  primaryExpression = value
                    | Identifier:i               -> ast.Variable(i)
                    | '(' ws expression:a ws ')' -> a,


  // --[ Entry points ]
  Program = ws seq('%furipota/1') (ws declaration)*:xs ws eof
            -> ast.Program(xs)
}
