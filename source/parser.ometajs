//----------------------------------------------------------------------
//
// This source file is part of the furipota project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

const ast = require('./ast');

var reserved = [
  'define',
  'import',
  'true',
  'false'
];

function isValid(id) {
  return reserved.indexOf(id) === -1;
}


ometa FuripotaParser {
  // --[ Lexical structure ]
  space   = /\s/,
  ignored = space | comment,
  comment = fromTo('#', '\n'):a -> a.slice(1),
  ws      = ignored*,
  sws     = ignored+,
  kw :xs  = seq(xs) ~(letter | digit | '-' | '_' | ':'),
  idStart = letter,
  idRest  = (letter | digit | '-' | '_'),
  eof     = ~char,

  octDigits = /[0-7][0-7_]*/:a             -> a.replace(/_/g, ''),
  hexDigits = /[0-9a-fA-F][0-9a-fA-F_]*/:a -> a.replace(/_/g, ''),
  binDigits = /[01][01_]*/:a               -> a.replace(/_/g, ''),
  digits = /[0-9][0-9_]*/:a                -> a.replace(/_/g, ''),

  exponent = ('e' | 'E') sign?:s digits:d -> s + d,
  sign = '+' | '-',

  stringEscape = '\\' ( 'b' -> '\b'
                      | 'f' -> '\f'
                      | 'n' -> '\n'
                      | 'r' -> '\r'
                      | 't' -> '\t'
                      | char),

  stringChar = stringEscape
             | (~seq('"') char):a -> a,
  unescapableChars = ~seq('"""') char,


  Identifier = <idStart idRest*>:a ?isValid(a)
               -> ast.Identifier(a),

  Keyword = <idStart idRest*>:a ':'
            -> ast.Keyword(a),


  // --[ Values ]
  value = Boolean | Number | Text | Vector | Record | Lambda,

  Boolean = kw('true') -> ast.Boolean(true)
          | kw('false') -> ast.Boolean(false),

  Number = sign?:s ( '0' 'b' binDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 2).toString())
                   | '0' 'o' octDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 8).toString())
                   | '0' 'x' hexDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 16).toString())
                   | digits:a '.' digits:b exponent?:c
                     -> ast.Decimal(s || '+', a, b, c || '')
                   | digits:a
                     -> ast.Integer(s || '+', a)
                   ),


  Text = seq('"""') <unescapableChars*>:as seq('"""')
         -> ast.Text(as)
       | '"' stringChar*:as '"'
         -> ast.Text(as.join('')),

  Vector = '[' ws ']'
           -> ast.Vector([])
         | expression:a (ws ',' ws expression)*:as
           -> ast.Vector([a].concat(as)),

  Record = '{' ws '}'
           -> ast.Record([])
         | recordPair:a (sws recordPair)*:xs
           -> ast.Record([a].concat(xs)),

  recordPair = Keyword:k ws recordExpression:v -> [k, v],

  recordExpression = primaryExpression
                   | Vector,

  Lambda = '|' ws Identifier:a (ws Identifier)?:r ws '|' ws expression:e
         -> ast.Lambda(a, r || ast.Identifier('_'), e),


  // --[ Declarations ]
  declaration = Define | Import,

  Define = kw('define') ws Identifier:i ws '=' ws expression:e
           -> ast.Define(i, e),

  Import = kw('import') ws Text:p
           -> ast.Import(p),


  // --[ Expressions ]
  expression = Pipe
             | Lambda
             | Record
             | Vector,

  Pipe = Pipe:a ws '>' ws Invoke:t
         -> ast.Pipe(a, t)
       | Invoke,

  Invoke = Invoke:i ws primaryExpression:v ws Record?:r
           -> ast.Invoke(i, v, r || ast.Record([]))
         | Invoke:i ws '_' ws Record?:r
           -> ast.Partial(i, r || ast.Record([]))
         | primaryExpression,

  primaryExpression = Boolean
                    | Text
                    | Number
                    | Identifier:i               -> ast.Variable(i)
                    | '(' ws expression:a ws ')' -> a,


  // --[ Entry points ]
  Program = ws seq('%furipota/1') (ws declaration)*:xs ws eof
            -> ast.Program(xs)
}
