//----------------------------------------------------------------------
//
// This source file is part of the furipota project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

const ast = require('./ast');

var reserved = [
  'define',
  'import', 'core', 'plugin', 'export', 'as',
  'true', 'false',
  'let', 'in',
  'if', 'then', 'else',
  'and', 'or', 'not',
  'default'
];

function isValid(id) {
  return reserved.indexOf(id) === -1;
}

function makeLambda(args, expr) {
  const lastArg = args[args.length - 2];
  const recordArg = args[args.length - 1];
  return args.slice(0, -2).reduceRight(function(fn, arg) {
    return ast.Lambda(arg, ast.Identifier('_'), fn);
  }, ast.Lambda(lastArg, recordArg, expr));
}


ometa FuripotaParser {
  // --[ Lexical structure ]
  space   = /\s/,
  ignored = space | comment,
  comment = fromTo('#', '\n'):a -> a.slice(1),
  ws      = ignored*,
  sws     = ignored+,
  kw :xs  = seq(xs) ~(letter | digit | '-' | '_' | ':'),
  idStart = letter,
  idRest  = (letter | digit | '-' | '_'),
  eof     = ~char,

  octDigits = /[0-7][0-7_]*/:a             -> a.replace(/_/g, ''),
  hexDigits = /[0-9a-fA-F][0-9a-fA-F_]*/:a -> a.replace(/_/g, ''),
  binDigits = /[01][01_]*/:a               -> a.replace(/_/g, ''),
  digits = /[0-9][0-9_]*/:a                -> a.replace(/_/g, ''),

  exponent = ('e' | 'E') sign?:s digits:d -> s + d,
  sign = '+' | '-',

  stringEscape = '\\' ( 'b' -> '\b'
                      | 'f' -> '\f'
                      | 'n' -> '\n'
                      | 'r' -> '\r'
                      | 't' -> '\t'
                      | char),

  stringChar = stringEscape
             | (~seq('"') char):a -> a,
  unescapableChars = ~seq('"""') char,


  Identifier = <idStart idRest*>:a ?isValid(a)
               -> ast.Identifier(a),

  Keyword = <idStart idRest*>:a ':'
            -> ast.Keyword(a),


  // --[ Values ]
  value = Boolean | Number | Text | Vector | Record | Lambda | Tagged,

  Boolean = kw('true') -> ast.Boolean(true)
          | kw('false') -> ast.Boolean(false),

  Number = sign?:s ( '0' 'b' binDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 2).toString())
                   | '0' 'o' octDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 8).toString())
                   | '0' 'x' hexDigits:n
                     -> ast.Integer(s || '+', parseInt(n, 16).toString())
                   | digits:a '.' digits:b exponent?:c
                     -> ast.Decimal(s || '+', a, b, c || '')
                   | digits:a
                     -> ast.Integer(s || '+', a)
                   ),


  Text = seq('"""') <unescapableChars*>:as seq('"""')
         -> ast.Text(as)
       | '"' stringChar*:as '"'
         -> ast.Text(as.join('')),

  Vector = '[' ws ']'
           -> ast.Vector([])
         | '[' ws expression:a (ws ',' ws expression)*:as ws ']'
           -> ast.Vector([a].concat(as)),

  Record = '{' ws '}'
           -> ast.Record([])
         | recordPair:a (sws recordPair)*:xs
           -> ast.Record([a].concat(xs)),

  recordPair = Keyword:k ws recordExpression:v -> [k, v],

  recordExpression = simpleExpression
                   | Vector,

  Lambda = '|' (ws Identifier)+:as (ws '@' ws Identifier)?:r ws '|' ws expression:e
         -> makeLambda(as.concat([r || ast.Identifier('_')]), e),

  Tagged = '^' Identifier:i ws simpleExpression:e
           -> ast.Tagged(i, e),


  // --[ Declarations ]
  declaration = Define | Import | Export,

  Define = kw('define') ws Identifier:i ws '=' doc?:d ws expression:e
           -> ast.Define(i, e, d || '')
         | kw('define') ws Identifier:i ws argNames:as ws '=' doc?:d ws expression:e
           -> ast.Define(i, makeLambda(as, e), d || ''),

  argNames = (ws Identifier)+:as (ws '@' Identifier)?:r -> as.concat([r || ast.Identifier('_')]),
  doc = (space* comment)*:xs -> xs.join(''),

  Import = kw('import') ws importKind?:k ws Text:p ws kw('as') ws Identifier:i
           -> ast.ImportAliasing(p, i, k || 'furipota')
         | kw('import') ws importKind?:k ws Text:p
           -> ast.Import(p, k || 'furipota'),

  importKind = kw('core') | kw('plugin'),

  Export = kw('export') ws Define:d
           -> ast.Seq([d, ast.Export(d.id)])
         | kw('export') ws Identifier:i ws kw('as') ws Identifier:a
           -> ast.ExportAliasing(i, a)
         | kw('export') ws Identifier:i
           -> ast.Export(i),

  // --[ Expressions ]
  expression = Pipe
             | Lambda
             | Record
             | Let
             | IfThenElse,

  Let = kw('let') ws Identifier:i ws '=' ws expression:v ws kw('in') ws expression:e
        -> ast.Let(i, v, e)
      | kw('let') ws Identifier:i ws argNames:as ws '=' ws expression:v ws kw('in') ws expression:e
        -> ast.Let(i, makeLambda(as, v), e),

  IfThenElse = kw('if') ws expression:c
                 ws kw('then') ws expression:t
                 ws kw('else') ws expression:e
               -> ast.IfThenElse(c, t, e),

  Pipe = Pipe:a ws seq('|>') ws Logical:t
         -> ast.Pipe(a, t)
       | Logical,

  Logical = Logical:a ws (kw('and') | kw('or')):o ws Relational:b
            -> ast.Infix(ast.Variable(ast.Identifier(o)), a, b)
          | Relational
          | Infix,

  Relational = Relational:a ws (seq('===') | seq('=/=') | '>' | seq('>=') | '<' | seq('<=')):o ws Add:b
               -> ast.Infix(ast.Variable(ast.Identifier(o)), a, b)
             | Add,
  
  Add = Add:a ws ('+' | '-'):o ws Multiply:b
        -> ast.Infix(ast.Variable(ast.Identifier(o)), a, b)
      | Multiply,

  Multiply = Multiply:a ws ('*' | '/'):o sws Unary:b
             -> ast.Infix(ast.Variable(ast.Identifier(o)), a, b)
           | Unary,

  Infix = Infix:l ws '`' Identifier:i ws Unary:b
          -> ast.Infix(ast.Variable(i), l, b)
        | Infix:l sws '`' qualifiedIdentifier:i ws Unary:b
          -> ast.Infix(i, l, b),

  qualifiedIdentifier = qualifiedIdentifier:a ws '.' ws Identifier:i
                        -> ast.Get(a, i),

  Unary = kw('not') ws Invoke:e
          -> ast.Prefix(ast.Identifier('not'), e)
        | Invoke,

  Invoke = Invoke:i ws memberExpression:v ws Record?:r
           -> ast.Invoke(i, v, r || ast.Record([]))
         | Invoke:i ws '_' ws Record?:r
           -> ast.Partial(i, r || ast.Record([]))
         | memberExpression,

  memberExpression = memberExpression:m ws '.' ws Identifier:i
                     -> ast.Get(m, i)
                   | simpleExpression,

  simpleExpression = Boolean
                   | Text
                   | Number
                   | Vector
                   | Tagged
                   | Identifier:i               -> ast.Variable(i)
                   | '(' ws expression:a ws ')' -> a,


  // --[ Entry points ]
  Program = ws seq('%furipota/1') (ws declaration)*:xs ws eof
            -> ast.Program(xs)
}
